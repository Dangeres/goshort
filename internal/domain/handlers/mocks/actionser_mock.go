// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/Dangeres/goshort/internal/domain/handlers.Actionser -o actionser_mock.go -n ActionserMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/Dangeres/goshort/internal/structures"
	"github.com/gojuno/minimock/v3"
)

// ActionserMock implements handlers.Actionser
type ActionserMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcGet          func(ctx context.Context, g1 structures.GetIn) (i1 structures.InRedisData, err error)
	inspectFuncGet   func(ctx context.Context, g1 structures.GetIn)
	afterGetCounter  uint64
	beforeGetCounter uint64
	GetMock          mActionserMockGet

	funcPost          func(ctx context.Context, s1 structures.ShortIn) (s2 structures.ShortOut, err error)
	inspectFuncPost   func(ctx context.Context, s1 structures.ShortIn)
	afterPostCounter  uint64
	beforePostCounter uint64
	PostMock          mActionserMockPost
}

// NewActionserMock returns a mock for handlers.Actionser
func NewActionserMock(t minimock.Tester) *ActionserMock {
	m := &ActionserMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetMock = mActionserMockGet{mock: m}
	m.GetMock.callArgs = []*ActionserMockGetParams{}

	m.PostMock = mActionserMockPost{mock: m}
	m.PostMock.callArgs = []*ActionserMockPostParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mActionserMockGet struct {
	mock               *ActionserMock
	defaultExpectation *ActionserMockGetExpectation
	expectations       []*ActionserMockGetExpectation

	callArgs []*ActionserMockGetParams
	mutex    sync.RWMutex
}

// ActionserMockGetExpectation specifies expectation struct of the Actionser.Get
type ActionserMockGetExpectation struct {
	mock      *ActionserMock
	params    *ActionserMockGetParams
	paramPtrs *ActionserMockGetParamPtrs
	results   *ActionserMockGetResults
	Counter   uint64
}

// ActionserMockGetParams contains parameters of the Actionser.Get
type ActionserMockGetParams struct {
	ctx context.Context
	g1  structures.GetIn
}

// ActionserMockGetParamPtrs contains pointers to parameters of the Actionser.Get
type ActionserMockGetParamPtrs struct {
	ctx *context.Context
	g1  *structures.GetIn
}

// ActionserMockGetResults contains results of the Actionser.Get
type ActionserMockGetResults struct {
	i1  structures.InRedisData
	err error
}

// Expect sets up expected params for Actionser.Get
func (mmGet *mActionserMockGet) Expect(ctx context.Context, g1 structures.GetIn) *mActionserMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("ActionserMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &ActionserMockGetExpectation{}
	}

	if mmGet.defaultExpectation.paramPtrs != nil {
		mmGet.mock.t.Fatalf("ActionserMock.Get mock is already set by ExpectParams functions")
	}

	mmGet.defaultExpectation.params = &ActionserMockGetParams{ctx, g1}
	for _, e := range mmGet.expectations {
		if minimock.Equal(e.params, mmGet.defaultExpectation.params) {
			mmGet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGet.defaultExpectation.params)
		}
	}

	return mmGet
}

// ExpectCtxParam1 sets up expected param ctx for Actionser.Get
func (mmGet *mActionserMockGet) ExpectCtxParam1(ctx context.Context) *mActionserMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("ActionserMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &ActionserMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("ActionserMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &ActionserMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGet
}

// ExpectG1Param2 sets up expected param g1 for Actionser.Get
func (mmGet *mActionserMockGet) ExpectG1Param2(g1 structures.GetIn) *mActionserMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("ActionserMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &ActionserMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("ActionserMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &ActionserMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.g1 = &g1

	return mmGet
}

// Inspect accepts an inspector function that has same arguments as the Actionser.Get
func (mmGet *mActionserMockGet) Inspect(f func(ctx context.Context, g1 structures.GetIn)) *mActionserMockGet {
	if mmGet.mock.inspectFuncGet != nil {
		mmGet.mock.t.Fatalf("Inspect function is already set for ActionserMock.Get")
	}

	mmGet.mock.inspectFuncGet = f

	return mmGet
}

// Return sets up results that will be returned by Actionser.Get
func (mmGet *mActionserMockGet) Return(i1 structures.InRedisData, err error) *ActionserMock {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("ActionserMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &ActionserMockGetExpectation{mock: mmGet.mock}
	}
	mmGet.defaultExpectation.results = &ActionserMockGetResults{i1, err}
	return mmGet.mock
}

// Set uses given function f to mock the Actionser.Get method
func (mmGet *mActionserMockGet) Set(f func(ctx context.Context, g1 structures.GetIn) (i1 structures.InRedisData, err error)) *ActionserMock {
	if mmGet.defaultExpectation != nil {
		mmGet.mock.t.Fatalf("Default expectation is already set for the Actionser.Get method")
	}

	if len(mmGet.expectations) > 0 {
		mmGet.mock.t.Fatalf("Some expectations are already set for the Actionser.Get method")
	}

	mmGet.mock.funcGet = f
	return mmGet.mock
}

// When sets expectation for the Actionser.Get which will trigger the result defined by the following
// Then helper
func (mmGet *mActionserMockGet) When(ctx context.Context, g1 structures.GetIn) *ActionserMockGetExpectation {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("ActionserMock.Get mock is already set by Set")
	}

	expectation := &ActionserMockGetExpectation{
		mock:   mmGet.mock,
		params: &ActionserMockGetParams{ctx, g1},
	}
	mmGet.expectations = append(mmGet.expectations, expectation)
	return expectation
}

// Then sets up Actionser.Get return parameters for the expectation previously defined by the When method
func (e *ActionserMockGetExpectation) Then(i1 structures.InRedisData, err error) *ActionserMock {
	e.results = &ActionserMockGetResults{i1, err}
	return e.mock
}

// Get implements handlers.Actionser
func (mmGet *ActionserMock) Get(ctx context.Context, g1 structures.GetIn) (i1 structures.InRedisData, err error) {
	mm_atomic.AddUint64(&mmGet.beforeGetCounter, 1)
	defer mm_atomic.AddUint64(&mmGet.afterGetCounter, 1)

	if mmGet.inspectFuncGet != nil {
		mmGet.inspectFuncGet(ctx, g1)
	}

	mm_params := ActionserMockGetParams{ctx, g1}

	// Record call args
	mmGet.GetMock.mutex.Lock()
	mmGet.GetMock.callArgs = append(mmGet.GetMock.callArgs, &mm_params)
	mmGet.GetMock.mutex.Unlock()

	for _, e := range mmGet.GetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmGet.GetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGet.GetMock.defaultExpectation.Counter, 1)
		mm_want := mmGet.GetMock.defaultExpectation.params
		mm_want_ptrs := mmGet.GetMock.defaultExpectation.paramPtrs

		mm_got := ActionserMockGetParams{ctx, g1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGet.t.Errorf("ActionserMock.Get got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.g1 != nil && !minimock.Equal(*mm_want_ptrs.g1, mm_got.g1) {
				mmGet.t.Errorf("ActionserMock.Get got unexpected parameter g1, want: %#v, got: %#v%s\n", *mm_want_ptrs.g1, mm_got.g1, minimock.Diff(*mm_want_ptrs.g1, mm_got.g1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGet.t.Errorf("ActionserMock.Get got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGet.GetMock.defaultExpectation.results
		if mm_results == nil {
			mmGet.t.Fatal("No results are set for the ActionserMock.Get")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmGet.funcGet != nil {
		return mmGet.funcGet(ctx, g1)
	}
	mmGet.t.Fatalf("Unexpected call to ActionserMock.Get. %v %v", ctx, g1)
	return
}

// GetAfterCounter returns a count of finished ActionserMock.Get invocations
func (mmGet *ActionserMock) GetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.afterGetCounter)
}

// GetBeforeCounter returns a count of ActionserMock.Get invocations
func (mmGet *ActionserMock) GetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.beforeGetCounter)
}

// Calls returns a list of arguments used in each call to ActionserMock.Get.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGet *mActionserMockGet) Calls() []*ActionserMockGetParams {
	mmGet.mutex.RLock()

	argCopy := make([]*ActionserMockGetParams, len(mmGet.callArgs))
	copy(argCopy, mmGet.callArgs)

	mmGet.mutex.RUnlock()

	return argCopy
}

// MinimockGetDone returns true if the count of the Get invocations corresponds
// the number of defined expectations
func (m *ActionserMock) MinimockGetDone() bool {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetInspect logs each unmet expectation
func (m *ActionserMock) MinimockGetInspect() {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ActionserMock.Get with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		if m.GetMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ActionserMock.Get")
		} else {
			m.t.Errorf("Expected call to ActionserMock.Get with params: %#v", *m.GetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		m.t.Error("Expected call to ActionserMock.Get")
	}
}

type mActionserMockPost struct {
	mock               *ActionserMock
	defaultExpectation *ActionserMockPostExpectation
	expectations       []*ActionserMockPostExpectation

	callArgs []*ActionserMockPostParams
	mutex    sync.RWMutex
}

// ActionserMockPostExpectation specifies expectation struct of the Actionser.Post
type ActionserMockPostExpectation struct {
	mock      *ActionserMock
	params    *ActionserMockPostParams
	paramPtrs *ActionserMockPostParamPtrs
	results   *ActionserMockPostResults
	Counter   uint64
}

// ActionserMockPostParams contains parameters of the Actionser.Post
type ActionserMockPostParams struct {
	ctx context.Context
	s1  structures.ShortIn
}

// ActionserMockPostParamPtrs contains pointers to parameters of the Actionser.Post
type ActionserMockPostParamPtrs struct {
	ctx *context.Context
	s1  *structures.ShortIn
}

// ActionserMockPostResults contains results of the Actionser.Post
type ActionserMockPostResults struct {
	s2  structures.ShortOut
	err error
}

// Expect sets up expected params for Actionser.Post
func (mmPost *mActionserMockPost) Expect(ctx context.Context, s1 structures.ShortIn) *mActionserMockPost {
	if mmPost.mock.funcPost != nil {
		mmPost.mock.t.Fatalf("ActionserMock.Post mock is already set by Set")
	}

	if mmPost.defaultExpectation == nil {
		mmPost.defaultExpectation = &ActionserMockPostExpectation{}
	}

	if mmPost.defaultExpectation.paramPtrs != nil {
		mmPost.mock.t.Fatalf("ActionserMock.Post mock is already set by ExpectParams functions")
	}

	mmPost.defaultExpectation.params = &ActionserMockPostParams{ctx, s1}
	for _, e := range mmPost.expectations {
		if minimock.Equal(e.params, mmPost.defaultExpectation.params) {
			mmPost.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPost.defaultExpectation.params)
		}
	}

	return mmPost
}

// ExpectCtxParam1 sets up expected param ctx for Actionser.Post
func (mmPost *mActionserMockPost) ExpectCtxParam1(ctx context.Context) *mActionserMockPost {
	if mmPost.mock.funcPost != nil {
		mmPost.mock.t.Fatalf("ActionserMock.Post mock is already set by Set")
	}

	if mmPost.defaultExpectation == nil {
		mmPost.defaultExpectation = &ActionserMockPostExpectation{}
	}

	if mmPost.defaultExpectation.params != nil {
		mmPost.mock.t.Fatalf("ActionserMock.Post mock is already set by Expect")
	}

	if mmPost.defaultExpectation.paramPtrs == nil {
		mmPost.defaultExpectation.paramPtrs = &ActionserMockPostParamPtrs{}
	}
	mmPost.defaultExpectation.paramPtrs.ctx = &ctx

	return mmPost
}

// ExpectS1Param2 sets up expected param s1 for Actionser.Post
func (mmPost *mActionserMockPost) ExpectS1Param2(s1 structures.ShortIn) *mActionserMockPost {
	if mmPost.mock.funcPost != nil {
		mmPost.mock.t.Fatalf("ActionserMock.Post mock is already set by Set")
	}

	if mmPost.defaultExpectation == nil {
		mmPost.defaultExpectation = &ActionserMockPostExpectation{}
	}

	if mmPost.defaultExpectation.params != nil {
		mmPost.mock.t.Fatalf("ActionserMock.Post mock is already set by Expect")
	}

	if mmPost.defaultExpectation.paramPtrs == nil {
		mmPost.defaultExpectation.paramPtrs = &ActionserMockPostParamPtrs{}
	}
	mmPost.defaultExpectation.paramPtrs.s1 = &s1

	return mmPost
}

// Inspect accepts an inspector function that has same arguments as the Actionser.Post
func (mmPost *mActionserMockPost) Inspect(f func(ctx context.Context, s1 structures.ShortIn)) *mActionserMockPost {
	if mmPost.mock.inspectFuncPost != nil {
		mmPost.mock.t.Fatalf("Inspect function is already set for ActionserMock.Post")
	}

	mmPost.mock.inspectFuncPost = f

	return mmPost
}

// Return sets up results that will be returned by Actionser.Post
func (mmPost *mActionserMockPost) Return(s2 structures.ShortOut, err error) *ActionserMock {
	if mmPost.mock.funcPost != nil {
		mmPost.mock.t.Fatalf("ActionserMock.Post mock is already set by Set")
	}

	if mmPost.defaultExpectation == nil {
		mmPost.defaultExpectation = &ActionserMockPostExpectation{mock: mmPost.mock}
	}
	mmPost.defaultExpectation.results = &ActionserMockPostResults{s2, err}
	return mmPost.mock
}

// Set uses given function f to mock the Actionser.Post method
func (mmPost *mActionserMockPost) Set(f func(ctx context.Context, s1 structures.ShortIn) (s2 structures.ShortOut, err error)) *ActionserMock {
	if mmPost.defaultExpectation != nil {
		mmPost.mock.t.Fatalf("Default expectation is already set for the Actionser.Post method")
	}

	if len(mmPost.expectations) > 0 {
		mmPost.mock.t.Fatalf("Some expectations are already set for the Actionser.Post method")
	}

	mmPost.mock.funcPost = f
	return mmPost.mock
}

// When sets expectation for the Actionser.Post which will trigger the result defined by the following
// Then helper
func (mmPost *mActionserMockPost) When(ctx context.Context, s1 structures.ShortIn) *ActionserMockPostExpectation {
	if mmPost.mock.funcPost != nil {
		mmPost.mock.t.Fatalf("ActionserMock.Post mock is already set by Set")
	}

	expectation := &ActionserMockPostExpectation{
		mock:   mmPost.mock,
		params: &ActionserMockPostParams{ctx, s1},
	}
	mmPost.expectations = append(mmPost.expectations, expectation)
	return expectation
}

// Then sets up Actionser.Post return parameters for the expectation previously defined by the When method
func (e *ActionserMockPostExpectation) Then(s2 structures.ShortOut, err error) *ActionserMock {
	e.results = &ActionserMockPostResults{s2, err}
	return e.mock
}

// Post implements handlers.Actionser
func (mmPost *ActionserMock) Post(ctx context.Context, s1 structures.ShortIn) (s2 structures.ShortOut, err error) {
	mm_atomic.AddUint64(&mmPost.beforePostCounter, 1)
	defer mm_atomic.AddUint64(&mmPost.afterPostCounter, 1)

	if mmPost.inspectFuncPost != nil {
		mmPost.inspectFuncPost(ctx, s1)
	}

	mm_params := ActionserMockPostParams{ctx, s1}

	// Record call args
	mmPost.PostMock.mutex.Lock()
	mmPost.PostMock.callArgs = append(mmPost.PostMock.callArgs, &mm_params)
	mmPost.PostMock.mutex.Unlock()

	for _, e := range mmPost.PostMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s2, e.results.err
		}
	}

	if mmPost.PostMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPost.PostMock.defaultExpectation.Counter, 1)
		mm_want := mmPost.PostMock.defaultExpectation.params
		mm_want_ptrs := mmPost.PostMock.defaultExpectation.paramPtrs

		mm_got := ActionserMockPostParams{ctx, s1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmPost.t.Errorf("ActionserMock.Post got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.s1 != nil && !minimock.Equal(*mm_want_ptrs.s1, mm_got.s1) {
				mmPost.t.Errorf("ActionserMock.Post got unexpected parameter s1, want: %#v, got: %#v%s\n", *mm_want_ptrs.s1, mm_got.s1, minimock.Diff(*mm_want_ptrs.s1, mm_got.s1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPost.t.Errorf("ActionserMock.Post got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPost.PostMock.defaultExpectation.results
		if mm_results == nil {
			mmPost.t.Fatal("No results are set for the ActionserMock.Post")
		}
		return (*mm_results).s2, (*mm_results).err
	}
	if mmPost.funcPost != nil {
		return mmPost.funcPost(ctx, s1)
	}
	mmPost.t.Fatalf("Unexpected call to ActionserMock.Post. %v %v", ctx, s1)
	return
}

// PostAfterCounter returns a count of finished ActionserMock.Post invocations
func (mmPost *ActionserMock) PostAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPost.afterPostCounter)
}

// PostBeforeCounter returns a count of ActionserMock.Post invocations
func (mmPost *ActionserMock) PostBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPost.beforePostCounter)
}

// Calls returns a list of arguments used in each call to ActionserMock.Post.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPost *mActionserMockPost) Calls() []*ActionserMockPostParams {
	mmPost.mutex.RLock()

	argCopy := make([]*ActionserMockPostParams, len(mmPost.callArgs))
	copy(argCopy, mmPost.callArgs)

	mmPost.mutex.RUnlock()

	return argCopy
}

// MinimockPostDone returns true if the count of the Post invocations corresponds
// the number of defined expectations
func (m *ActionserMock) MinimockPostDone() bool {
	for _, e := range m.PostMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PostMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPostCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPost != nil && mm_atomic.LoadUint64(&m.afterPostCounter) < 1 {
		return false
	}
	return true
}

// MinimockPostInspect logs each unmet expectation
func (m *ActionserMock) MinimockPostInspect() {
	for _, e := range m.PostMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ActionserMock.Post with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PostMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPostCounter) < 1 {
		if m.PostMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ActionserMock.Post")
		} else {
			m.t.Errorf("Expected call to ActionserMock.Post with params: %#v", *m.PostMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPost != nil && mm_atomic.LoadUint64(&m.afterPostCounter) < 1 {
		m.t.Error("Expected call to ActionserMock.Post")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ActionserMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockGetInspect()

			m.MinimockPostInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ActionserMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ActionserMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetDone() &&
		m.MinimockPostDone()
}
