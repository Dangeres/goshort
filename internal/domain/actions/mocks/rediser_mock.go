// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/Dangeres/goshort/internal/domain/actions.Rediser -o rediser_mock.go -n RediserMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	"time"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// RediserMock implements actions.Rediser
type RediserMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcClose          func() (err error)
	inspectFuncClose   func()
	afterCloseCounter  uint64
	beforeCloseCounter uint64
	CloseMock          mRediserMockClose

	funcExpire          func(ctx context.Context, s1 string) (i1 int64, err error)
	inspectFuncExpire   func(ctx context.Context, s1 string)
	afterExpireCounter  uint64
	beforeExpireCounter uint64
	ExpireMock          mRediserMockExpire

	funcGet          func(ctx context.Context, s1 string) (s2 string, err error)
	inspectFuncGet   func(ctx context.Context, s1 string)
	afterGetCounter  uint64
	beforeGetCounter uint64
	GetMock          mRediserMockGet

	funcPing          func() (err error)
	inspectFuncPing   func()
	afterPingCounter  uint64
	beforePingCounter uint64
	PingMock          mRediserMockPing

	funcSet          func(ctx context.Context, s1 string, ba1 []byte, d1 time.Duration) (s2 string, err error)
	inspectFuncSet   func(ctx context.Context, s1 string, ba1 []byte, d1 time.Duration)
	afterSetCounter  uint64
	beforeSetCounter uint64
	SetMock          mRediserMockSet
}

// NewRediserMock returns a mock for actions.Rediser
func NewRediserMock(t minimock.Tester) *RediserMock {
	m := &RediserMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CloseMock = mRediserMockClose{mock: m}

	m.ExpireMock = mRediserMockExpire{mock: m}
	m.ExpireMock.callArgs = []*RediserMockExpireParams{}

	m.GetMock = mRediserMockGet{mock: m}
	m.GetMock.callArgs = []*RediserMockGetParams{}

	m.PingMock = mRediserMockPing{mock: m}

	m.SetMock = mRediserMockSet{mock: m}
	m.SetMock.callArgs = []*RediserMockSetParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mRediserMockClose struct {
	mock               *RediserMock
	defaultExpectation *RediserMockCloseExpectation
	expectations       []*RediserMockCloseExpectation
}

// RediserMockCloseExpectation specifies expectation struct of the Rediser.Close
type RediserMockCloseExpectation struct {
	mock *RediserMock

	results *RediserMockCloseResults
	Counter uint64
}

// RediserMockCloseResults contains results of the Rediser.Close
type RediserMockCloseResults struct {
	err error
}

// Expect sets up expected params for Rediser.Close
func (mmClose *mRediserMockClose) Expect() *mRediserMockClose {
	if mmClose.mock.funcClose != nil {
		mmClose.mock.t.Fatalf("RediserMock.Close mock is already set by Set")
	}

	if mmClose.defaultExpectation == nil {
		mmClose.defaultExpectation = &RediserMockCloseExpectation{}
	}

	return mmClose
}

// Inspect accepts an inspector function that has same arguments as the Rediser.Close
func (mmClose *mRediserMockClose) Inspect(f func()) *mRediserMockClose {
	if mmClose.mock.inspectFuncClose != nil {
		mmClose.mock.t.Fatalf("Inspect function is already set for RediserMock.Close")
	}

	mmClose.mock.inspectFuncClose = f

	return mmClose
}

// Return sets up results that will be returned by Rediser.Close
func (mmClose *mRediserMockClose) Return(err error) *RediserMock {
	if mmClose.mock.funcClose != nil {
		mmClose.mock.t.Fatalf("RediserMock.Close mock is already set by Set")
	}

	if mmClose.defaultExpectation == nil {
		mmClose.defaultExpectation = &RediserMockCloseExpectation{mock: mmClose.mock}
	}
	mmClose.defaultExpectation.results = &RediserMockCloseResults{err}
	return mmClose.mock
}

// Set uses given function f to mock the Rediser.Close method
func (mmClose *mRediserMockClose) Set(f func() (err error)) *RediserMock {
	if mmClose.defaultExpectation != nil {
		mmClose.mock.t.Fatalf("Default expectation is already set for the Rediser.Close method")
	}

	if len(mmClose.expectations) > 0 {
		mmClose.mock.t.Fatalf("Some expectations are already set for the Rediser.Close method")
	}

	mmClose.mock.funcClose = f
	return mmClose.mock
}

// Close implements actions.Rediser
func (mmClose *RediserMock) Close() (err error) {
	mm_atomic.AddUint64(&mmClose.beforeCloseCounter, 1)
	defer mm_atomic.AddUint64(&mmClose.afterCloseCounter, 1)

	if mmClose.inspectFuncClose != nil {
		mmClose.inspectFuncClose()
	}

	if mmClose.CloseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmClose.CloseMock.defaultExpectation.Counter, 1)

		mm_results := mmClose.CloseMock.defaultExpectation.results
		if mm_results == nil {
			mmClose.t.Fatal("No results are set for the RediserMock.Close")
		}
		return (*mm_results).err
	}
	if mmClose.funcClose != nil {
		return mmClose.funcClose()
	}
	mmClose.t.Fatalf("Unexpected call to RediserMock.Close.")
	return
}

// CloseAfterCounter returns a count of finished RediserMock.Close invocations
func (mmClose *RediserMock) CloseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClose.afterCloseCounter)
}

// CloseBeforeCounter returns a count of RediserMock.Close invocations
func (mmClose *RediserMock) CloseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClose.beforeCloseCounter)
}

// MinimockCloseDone returns true if the count of the Close invocations corresponds
// the number of defined expectations
func (m *RediserMock) MinimockCloseDone() bool {
	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CloseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClose != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		return false
	}
	return true
}

// MinimockCloseInspect logs each unmet expectation
func (m *RediserMock) MinimockCloseInspect() {
	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RediserMock.Close")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CloseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		m.t.Error("Expected call to RediserMock.Close")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClose != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		m.t.Error("Expected call to RediserMock.Close")
	}
}

type mRediserMockExpire struct {
	mock               *RediserMock
	defaultExpectation *RediserMockExpireExpectation
	expectations       []*RediserMockExpireExpectation

	callArgs []*RediserMockExpireParams
	mutex    sync.RWMutex
}

// RediserMockExpireExpectation specifies expectation struct of the Rediser.Expire
type RediserMockExpireExpectation struct {
	mock      *RediserMock
	params    *RediserMockExpireParams
	paramPtrs *RediserMockExpireParamPtrs
	results   *RediserMockExpireResults
	Counter   uint64
}

// RediserMockExpireParams contains parameters of the Rediser.Expire
type RediserMockExpireParams struct {
	ctx context.Context
	s1  string
}

// RediserMockExpireParamPtrs contains pointers to parameters of the Rediser.Expire
type RediserMockExpireParamPtrs struct {
	ctx *context.Context
	s1  *string
}

// RediserMockExpireResults contains results of the Rediser.Expire
type RediserMockExpireResults struct {
	i1  int64
	err error
}

// Expect sets up expected params for Rediser.Expire
func (mmExpire *mRediserMockExpire) Expect(ctx context.Context, s1 string) *mRediserMockExpire {
	if mmExpire.mock.funcExpire != nil {
		mmExpire.mock.t.Fatalf("RediserMock.Expire mock is already set by Set")
	}

	if mmExpire.defaultExpectation == nil {
		mmExpire.defaultExpectation = &RediserMockExpireExpectation{}
	}

	if mmExpire.defaultExpectation.paramPtrs != nil {
		mmExpire.mock.t.Fatalf("RediserMock.Expire mock is already set by ExpectParams functions")
	}

	mmExpire.defaultExpectation.params = &RediserMockExpireParams{ctx, s1}
	for _, e := range mmExpire.expectations {
		if minimock.Equal(e.params, mmExpire.defaultExpectation.params) {
			mmExpire.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmExpire.defaultExpectation.params)
		}
	}

	return mmExpire
}

// ExpectCtxParam1 sets up expected param ctx for Rediser.Expire
func (mmExpire *mRediserMockExpire) ExpectCtxParam1(ctx context.Context) *mRediserMockExpire {
	if mmExpire.mock.funcExpire != nil {
		mmExpire.mock.t.Fatalf("RediserMock.Expire mock is already set by Set")
	}

	if mmExpire.defaultExpectation == nil {
		mmExpire.defaultExpectation = &RediserMockExpireExpectation{}
	}

	if mmExpire.defaultExpectation.params != nil {
		mmExpire.mock.t.Fatalf("RediserMock.Expire mock is already set by Expect")
	}

	if mmExpire.defaultExpectation.paramPtrs == nil {
		mmExpire.defaultExpectation.paramPtrs = &RediserMockExpireParamPtrs{}
	}
	mmExpire.defaultExpectation.paramPtrs.ctx = &ctx

	return mmExpire
}

// ExpectS1Param2 sets up expected param s1 for Rediser.Expire
func (mmExpire *mRediserMockExpire) ExpectS1Param2(s1 string) *mRediserMockExpire {
	if mmExpire.mock.funcExpire != nil {
		mmExpire.mock.t.Fatalf("RediserMock.Expire mock is already set by Set")
	}

	if mmExpire.defaultExpectation == nil {
		mmExpire.defaultExpectation = &RediserMockExpireExpectation{}
	}

	if mmExpire.defaultExpectation.params != nil {
		mmExpire.mock.t.Fatalf("RediserMock.Expire mock is already set by Expect")
	}

	if mmExpire.defaultExpectation.paramPtrs == nil {
		mmExpire.defaultExpectation.paramPtrs = &RediserMockExpireParamPtrs{}
	}
	mmExpire.defaultExpectation.paramPtrs.s1 = &s1

	return mmExpire
}

// Inspect accepts an inspector function that has same arguments as the Rediser.Expire
func (mmExpire *mRediserMockExpire) Inspect(f func(ctx context.Context, s1 string)) *mRediserMockExpire {
	if mmExpire.mock.inspectFuncExpire != nil {
		mmExpire.mock.t.Fatalf("Inspect function is already set for RediserMock.Expire")
	}

	mmExpire.mock.inspectFuncExpire = f

	return mmExpire
}

// Return sets up results that will be returned by Rediser.Expire
func (mmExpire *mRediserMockExpire) Return(i1 int64, err error) *RediserMock {
	if mmExpire.mock.funcExpire != nil {
		mmExpire.mock.t.Fatalf("RediserMock.Expire mock is already set by Set")
	}

	if mmExpire.defaultExpectation == nil {
		mmExpire.defaultExpectation = &RediserMockExpireExpectation{mock: mmExpire.mock}
	}
	mmExpire.defaultExpectation.results = &RediserMockExpireResults{i1, err}
	return mmExpire.mock
}

// Set uses given function f to mock the Rediser.Expire method
func (mmExpire *mRediserMockExpire) Set(f func(ctx context.Context, s1 string) (i1 int64, err error)) *RediserMock {
	if mmExpire.defaultExpectation != nil {
		mmExpire.mock.t.Fatalf("Default expectation is already set for the Rediser.Expire method")
	}

	if len(mmExpire.expectations) > 0 {
		mmExpire.mock.t.Fatalf("Some expectations are already set for the Rediser.Expire method")
	}

	mmExpire.mock.funcExpire = f
	return mmExpire.mock
}

// When sets expectation for the Rediser.Expire which will trigger the result defined by the following
// Then helper
func (mmExpire *mRediserMockExpire) When(ctx context.Context, s1 string) *RediserMockExpireExpectation {
	if mmExpire.mock.funcExpire != nil {
		mmExpire.mock.t.Fatalf("RediserMock.Expire mock is already set by Set")
	}

	expectation := &RediserMockExpireExpectation{
		mock:   mmExpire.mock,
		params: &RediserMockExpireParams{ctx, s1},
	}
	mmExpire.expectations = append(mmExpire.expectations, expectation)
	return expectation
}

// Then sets up Rediser.Expire return parameters for the expectation previously defined by the When method
func (e *RediserMockExpireExpectation) Then(i1 int64, err error) *RediserMock {
	e.results = &RediserMockExpireResults{i1, err}
	return e.mock
}

// Expire implements actions.Rediser
func (mmExpire *RediserMock) Expire(ctx context.Context, s1 string) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmExpire.beforeExpireCounter, 1)
	defer mm_atomic.AddUint64(&mmExpire.afterExpireCounter, 1)

	if mmExpire.inspectFuncExpire != nil {
		mmExpire.inspectFuncExpire(ctx, s1)
	}

	mm_params := RediserMockExpireParams{ctx, s1}

	// Record call args
	mmExpire.ExpireMock.mutex.Lock()
	mmExpire.ExpireMock.callArgs = append(mmExpire.ExpireMock.callArgs, &mm_params)
	mmExpire.ExpireMock.mutex.Unlock()

	for _, e := range mmExpire.ExpireMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmExpire.ExpireMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmExpire.ExpireMock.defaultExpectation.Counter, 1)
		mm_want := mmExpire.ExpireMock.defaultExpectation.params
		mm_want_ptrs := mmExpire.ExpireMock.defaultExpectation.paramPtrs

		mm_got := RediserMockExpireParams{ctx, s1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmExpire.t.Errorf("RediserMock.Expire got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.s1 != nil && !minimock.Equal(*mm_want_ptrs.s1, mm_got.s1) {
				mmExpire.t.Errorf("RediserMock.Expire got unexpected parameter s1, want: %#v, got: %#v%s\n", *mm_want_ptrs.s1, mm_got.s1, minimock.Diff(*mm_want_ptrs.s1, mm_got.s1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmExpire.t.Errorf("RediserMock.Expire got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmExpire.ExpireMock.defaultExpectation.results
		if mm_results == nil {
			mmExpire.t.Fatal("No results are set for the RediserMock.Expire")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmExpire.funcExpire != nil {
		return mmExpire.funcExpire(ctx, s1)
	}
	mmExpire.t.Fatalf("Unexpected call to RediserMock.Expire. %v %v", ctx, s1)
	return
}

// ExpireAfterCounter returns a count of finished RediserMock.Expire invocations
func (mmExpire *RediserMock) ExpireAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExpire.afterExpireCounter)
}

// ExpireBeforeCounter returns a count of RediserMock.Expire invocations
func (mmExpire *RediserMock) ExpireBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExpire.beforeExpireCounter)
}

// Calls returns a list of arguments used in each call to RediserMock.Expire.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmExpire *mRediserMockExpire) Calls() []*RediserMockExpireParams {
	mmExpire.mutex.RLock()

	argCopy := make([]*RediserMockExpireParams, len(mmExpire.callArgs))
	copy(argCopy, mmExpire.callArgs)

	mmExpire.mutex.RUnlock()

	return argCopy
}

// MinimockExpireDone returns true if the count of the Expire invocations corresponds
// the number of defined expectations
func (m *RediserMock) MinimockExpireDone() bool {
	for _, e := range m.ExpireMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ExpireMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterExpireCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcExpire != nil && mm_atomic.LoadUint64(&m.afterExpireCounter) < 1 {
		return false
	}
	return true
}

// MinimockExpireInspect logs each unmet expectation
func (m *RediserMock) MinimockExpireInspect() {
	for _, e := range m.ExpireMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RediserMock.Expire with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ExpireMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterExpireCounter) < 1 {
		if m.ExpireMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RediserMock.Expire")
		} else {
			m.t.Errorf("Expected call to RediserMock.Expire with params: %#v", *m.ExpireMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcExpire != nil && mm_atomic.LoadUint64(&m.afterExpireCounter) < 1 {
		m.t.Error("Expected call to RediserMock.Expire")
	}
}

type mRediserMockGet struct {
	mock               *RediserMock
	defaultExpectation *RediserMockGetExpectation
	expectations       []*RediserMockGetExpectation

	callArgs []*RediserMockGetParams
	mutex    sync.RWMutex
}

// RediserMockGetExpectation specifies expectation struct of the Rediser.Get
type RediserMockGetExpectation struct {
	mock      *RediserMock
	params    *RediserMockGetParams
	paramPtrs *RediserMockGetParamPtrs
	results   *RediserMockGetResults
	Counter   uint64
}

// RediserMockGetParams contains parameters of the Rediser.Get
type RediserMockGetParams struct {
	ctx context.Context
	s1  string
}

// RediserMockGetParamPtrs contains pointers to parameters of the Rediser.Get
type RediserMockGetParamPtrs struct {
	ctx *context.Context
	s1  *string
}

// RediserMockGetResults contains results of the Rediser.Get
type RediserMockGetResults struct {
	s2  string
	err error
}

// Expect sets up expected params for Rediser.Get
func (mmGet *mRediserMockGet) Expect(ctx context.Context, s1 string) *mRediserMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("RediserMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &RediserMockGetExpectation{}
	}

	if mmGet.defaultExpectation.paramPtrs != nil {
		mmGet.mock.t.Fatalf("RediserMock.Get mock is already set by ExpectParams functions")
	}

	mmGet.defaultExpectation.params = &RediserMockGetParams{ctx, s1}
	for _, e := range mmGet.expectations {
		if minimock.Equal(e.params, mmGet.defaultExpectation.params) {
			mmGet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGet.defaultExpectation.params)
		}
	}

	return mmGet
}

// ExpectCtxParam1 sets up expected param ctx for Rediser.Get
func (mmGet *mRediserMockGet) ExpectCtxParam1(ctx context.Context) *mRediserMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("RediserMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &RediserMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("RediserMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &RediserMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGet
}

// ExpectS1Param2 sets up expected param s1 for Rediser.Get
func (mmGet *mRediserMockGet) ExpectS1Param2(s1 string) *mRediserMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("RediserMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &RediserMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("RediserMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &RediserMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.s1 = &s1

	return mmGet
}

// Inspect accepts an inspector function that has same arguments as the Rediser.Get
func (mmGet *mRediserMockGet) Inspect(f func(ctx context.Context, s1 string)) *mRediserMockGet {
	if mmGet.mock.inspectFuncGet != nil {
		mmGet.mock.t.Fatalf("Inspect function is already set for RediserMock.Get")
	}

	mmGet.mock.inspectFuncGet = f

	return mmGet
}

// Return sets up results that will be returned by Rediser.Get
func (mmGet *mRediserMockGet) Return(s2 string, err error) *RediserMock {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("RediserMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &RediserMockGetExpectation{mock: mmGet.mock}
	}
	mmGet.defaultExpectation.results = &RediserMockGetResults{s2, err}
	return mmGet.mock
}

// Set uses given function f to mock the Rediser.Get method
func (mmGet *mRediserMockGet) Set(f func(ctx context.Context, s1 string) (s2 string, err error)) *RediserMock {
	if mmGet.defaultExpectation != nil {
		mmGet.mock.t.Fatalf("Default expectation is already set for the Rediser.Get method")
	}

	if len(mmGet.expectations) > 0 {
		mmGet.mock.t.Fatalf("Some expectations are already set for the Rediser.Get method")
	}

	mmGet.mock.funcGet = f
	return mmGet.mock
}

// When sets expectation for the Rediser.Get which will trigger the result defined by the following
// Then helper
func (mmGet *mRediserMockGet) When(ctx context.Context, s1 string) *RediserMockGetExpectation {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("RediserMock.Get mock is already set by Set")
	}

	expectation := &RediserMockGetExpectation{
		mock:   mmGet.mock,
		params: &RediserMockGetParams{ctx, s1},
	}
	mmGet.expectations = append(mmGet.expectations, expectation)
	return expectation
}

// Then sets up Rediser.Get return parameters for the expectation previously defined by the When method
func (e *RediserMockGetExpectation) Then(s2 string, err error) *RediserMock {
	e.results = &RediserMockGetResults{s2, err}
	return e.mock
}

// Get implements actions.Rediser
func (mmGet *RediserMock) Get(ctx context.Context, s1 string) (s2 string, err error) {
	mm_atomic.AddUint64(&mmGet.beforeGetCounter, 1)
	defer mm_atomic.AddUint64(&mmGet.afterGetCounter, 1)

	if mmGet.inspectFuncGet != nil {
		mmGet.inspectFuncGet(ctx, s1)
	}

	mm_params := RediserMockGetParams{ctx, s1}

	// Record call args
	mmGet.GetMock.mutex.Lock()
	mmGet.GetMock.callArgs = append(mmGet.GetMock.callArgs, &mm_params)
	mmGet.GetMock.mutex.Unlock()

	for _, e := range mmGet.GetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s2, e.results.err
		}
	}

	if mmGet.GetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGet.GetMock.defaultExpectation.Counter, 1)
		mm_want := mmGet.GetMock.defaultExpectation.params
		mm_want_ptrs := mmGet.GetMock.defaultExpectation.paramPtrs

		mm_got := RediserMockGetParams{ctx, s1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGet.t.Errorf("RediserMock.Get got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.s1 != nil && !minimock.Equal(*mm_want_ptrs.s1, mm_got.s1) {
				mmGet.t.Errorf("RediserMock.Get got unexpected parameter s1, want: %#v, got: %#v%s\n", *mm_want_ptrs.s1, mm_got.s1, minimock.Diff(*mm_want_ptrs.s1, mm_got.s1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGet.t.Errorf("RediserMock.Get got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGet.GetMock.defaultExpectation.results
		if mm_results == nil {
			mmGet.t.Fatal("No results are set for the RediserMock.Get")
		}
		return (*mm_results).s2, (*mm_results).err
	}
	if mmGet.funcGet != nil {
		return mmGet.funcGet(ctx, s1)
	}
	mmGet.t.Fatalf("Unexpected call to RediserMock.Get. %v %v", ctx, s1)
	return
}

// GetAfterCounter returns a count of finished RediserMock.Get invocations
func (mmGet *RediserMock) GetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.afterGetCounter)
}

// GetBeforeCounter returns a count of RediserMock.Get invocations
func (mmGet *RediserMock) GetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.beforeGetCounter)
}

// Calls returns a list of arguments used in each call to RediserMock.Get.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGet *mRediserMockGet) Calls() []*RediserMockGetParams {
	mmGet.mutex.RLock()

	argCopy := make([]*RediserMockGetParams, len(mmGet.callArgs))
	copy(argCopy, mmGet.callArgs)

	mmGet.mutex.RUnlock()

	return argCopy
}

// MinimockGetDone returns true if the count of the Get invocations corresponds
// the number of defined expectations
func (m *RediserMock) MinimockGetDone() bool {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetInspect logs each unmet expectation
func (m *RediserMock) MinimockGetInspect() {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RediserMock.Get with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		if m.GetMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RediserMock.Get")
		} else {
			m.t.Errorf("Expected call to RediserMock.Get with params: %#v", *m.GetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		m.t.Error("Expected call to RediserMock.Get")
	}
}

type mRediserMockPing struct {
	mock               *RediserMock
	defaultExpectation *RediserMockPingExpectation
	expectations       []*RediserMockPingExpectation
}

// RediserMockPingExpectation specifies expectation struct of the Rediser.Ping
type RediserMockPingExpectation struct {
	mock *RediserMock

	results *RediserMockPingResults
	Counter uint64
}

// RediserMockPingResults contains results of the Rediser.Ping
type RediserMockPingResults struct {
	err error
}

// Expect sets up expected params for Rediser.Ping
func (mmPing *mRediserMockPing) Expect() *mRediserMockPing {
	if mmPing.mock.funcPing != nil {
		mmPing.mock.t.Fatalf("RediserMock.Ping mock is already set by Set")
	}

	if mmPing.defaultExpectation == nil {
		mmPing.defaultExpectation = &RediserMockPingExpectation{}
	}

	return mmPing
}

// Inspect accepts an inspector function that has same arguments as the Rediser.Ping
func (mmPing *mRediserMockPing) Inspect(f func()) *mRediserMockPing {
	if mmPing.mock.inspectFuncPing != nil {
		mmPing.mock.t.Fatalf("Inspect function is already set for RediserMock.Ping")
	}

	mmPing.mock.inspectFuncPing = f

	return mmPing
}

// Return sets up results that will be returned by Rediser.Ping
func (mmPing *mRediserMockPing) Return(err error) *RediserMock {
	if mmPing.mock.funcPing != nil {
		mmPing.mock.t.Fatalf("RediserMock.Ping mock is already set by Set")
	}

	if mmPing.defaultExpectation == nil {
		mmPing.defaultExpectation = &RediserMockPingExpectation{mock: mmPing.mock}
	}
	mmPing.defaultExpectation.results = &RediserMockPingResults{err}
	return mmPing.mock
}

// Set uses given function f to mock the Rediser.Ping method
func (mmPing *mRediserMockPing) Set(f func() (err error)) *RediserMock {
	if mmPing.defaultExpectation != nil {
		mmPing.mock.t.Fatalf("Default expectation is already set for the Rediser.Ping method")
	}

	if len(mmPing.expectations) > 0 {
		mmPing.mock.t.Fatalf("Some expectations are already set for the Rediser.Ping method")
	}

	mmPing.mock.funcPing = f
	return mmPing.mock
}

// Ping implements actions.Rediser
func (mmPing *RediserMock) Ping() (err error) {
	mm_atomic.AddUint64(&mmPing.beforePingCounter, 1)
	defer mm_atomic.AddUint64(&mmPing.afterPingCounter, 1)

	if mmPing.inspectFuncPing != nil {
		mmPing.inspectFuncPing()
	}

	if mmPing.PingMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPing.PingMock.defaultExpectation.Counter, 1)

		mm_results := mmPing.PingMock.defaultExpectation.results
		if mm_results == nil {
			mmPing.t.Fatal("No results are set for the RediserMock.Ping")
		}
		return (*mm_results).err
	}
	if mmPing.funcPing != nil {
		return mmPing.funcPing()
	}
	mmPing.t.Fatalf("Unexpected call to RediserMock.Ping.")
	return
}

// PingAfterCounter returns a count of finished RediserMock.Ping invocations
func (mmPing *RediserMock) PingAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPing.afterPingCounter)
}

// PingBeforeCounter returns a count of RediserMock.Ping invocations
func (mmPing *RediserMock) PingBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPing.beforePingCounter)
}

// MinimockPingDone returns true if the count of the Ping invocations corresponds
// the number of defined expectations
func (m *RediserMock) MinimockPingDone() bool {
	for _, e := range m.PingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PingMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPingCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPing != nil && mm_atomic.LoadUint64(&m.afterPingCounter) < 1 {
		return false
	}
	return true
}

// MinimockPingInspect logs each unmet expectation
func (m *RediserMock) MinimockPingInspect() {
	for _, e := range m.PingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RediserMock.Ping")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PingMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPingCounter) < 1 {
		m.t.Error("Expected call to RediserMock.Ping")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPing != nil && mm_atomic.LoadUint64(&m.afterPingCounter) < 1 {
		m.t.Error("Expected call to RediserMock.Ping")
	}
}

type mRediserMockSet struct {
	mock               *RediserMock
	defaultExpectation *RediserMockSetExpectation
	expectations       []*RediserMockSetExpectation

	callArgs []*RediserMockSetParams
	mutex    sync.RWMutex
}

// RediserMockSetExpectation specifies expectation struct of the Rediser.Set
type RediserMockSetExpectation struct {
	mock      *RediserMock
	params    *RediserMockSetParams
	paramPtrs *RediserMockSetParamPtrs
	results   *RediserMockSetResults
	Counter   uint64
}

// RediserMockSetParams contains parameters of the Rediser.Set
type RediserMockSetParams struct {
	ctx context.Context
	s1  string
	ba1 []byte
	d1  time.Duration
}

// RediserMockSetParamPtrs contains pointers to parameters of the Rediser.Set
type RediserMockSetParamPtrs struct {
	ctx *context.Context
	s1  *string
	ba1 *[]byte
	d1  *time.Duration
}

// RediserMockSetResults contains results of the Rediser.Set
type RediserMockSetResults struct {
	s2  string
	err error
}

// Expect sets up expected params for Rediser.Set
func (mmSet *mRediserMockSet) Expect(ctx context.Context, s1 string, ba1 []byte, d1 time.Duration) *mRediserMockSet {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("RediserMock.Set mock is already set by Set")
	}

	if mmSet.defaultExpectation == nil {
		mmSet.defaultExpectation = &RediserMockSetExpectation{}
	}

	if mmSet.defaultExpectation.paramPtrs != nil {
		mmSet.mock.t.Fatalf("RediserMock.Set mock is already set by ExpectParams functions")
	}

	mmSet.defaultExpectation.params = &RediserMockSetParams{ctx, s1, ba1, d1}
	for _, e := range mmSet.expectations {
		if minimock.Equal(e.params, mmSet.defaultExpectation.params) {
			mmSet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSet.defaultExpectation.params)
		}
	}

	return mmSet
}

// ExpectCtxParam1 sets up expected param ctx for Rediser.Set
func (mmSet *mRediserMockSet) ExpectCtxParam1(ctx context.Context) *mRediserMockSet {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("RediserMock.Set mock is already set by Set")
	}

	if mmSet.defaultExpectation == nil {
		mmSet.defaultExpectation = &RediserMockSetExpectation{}
	}

	if mmSet.defaultExpectation.params != nil {
		mmSet.mock.t.Fatalf("RediserMock.Set mock is already set by Expect")
	}

	if mmSet.defaultExpectation.paramPtrs == nil {
		mmSet.defaultExpectation.paramPtrs = &RediserMockSetParamPtrs{}
	}
	mmSet.defaultExpectation.paramPtrs.ctx = &ctx

	return mmSet
}

// ExpectS1Param2 sets up expected param s1 for Rediser.Set
func (mmSet *mRediserMockSet) ExpectS1Param2(s1 string) *mRediserMockSet {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("RediserMock.Set mock is already set by Set")
	}

	if mmSet.defaultExpectation == nil {
		mmSet.defaultExpectation = &RediserMockSetExpectation{}
	}

	if mmSet.defaultExpectation.params != nil {
		mmSet.mock.t.Fatalf("RediserMock.Set mock is already set by Expect")
	}

	if mmSet.defaultExpectation.paramPtrs == nil {
		mmSet.defaultExpectation.paramPtrs = &RediserMockSetParamPtrs{}
	}
	mmSet.defaultExpectation.paramPtrs.s1 = &s1

	return mmSet
}

// ExpectBa1Param3 sets up expected param ba1 for Rediser.Set
func (mmSet *mRediserMockSet) ExpectBa1Param3(ba1 []byte) *mRediserMockSet {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("RediserMock.Set mock is already set by Set")
	}

	if mmSet.defaultExpectation == nil {
		mmSet.defaultExpectation = &RediserMockSetExpectation{}
	}

	if mmSet.defaultExpectation.params != nil {
		mmSet.mock.t.Fatalf("RediserMock.Set mock is already set by Expect")
	}

	if mmSet.defaultExpectation.paramPtrs == nil {
		mmSet.defaultExpectation.paramPtrs = &RediserMockSetParamPtrs{}
	}
	mmSet.defaultExpectation.paramPtrs.ba1 = &ba1

	return mmSet
}

// ExpectD1Param4 sets up expected param d1 for Rediser.Set
func (mmSet *mRediserMockSet) ExpectD1Param4(d1 time.Duration) *mRediserMockSet {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("RediserMock.Set mock is already set by Set")
	}

	if mmSet.defaultExpectation == nil {
		mmSet.defaultExpectation = &RediserMockSetExpectation{}
	}

	if mmSet.defaultExpectation.params != nil {
		mmSet.mock.t.Fatalf("RediserMock.Set mock is already set by Expect")
	}

	if mmSet.defaultExpectation.paramPtrs == nil {
		mmSet.defaultExpectation.paramPtrs = &RediserMockSetParamPtrs{}
	}
	mmSet.defaultExpectation.paramPtrs.d1 = &d1

	return mmSet
}

// Inspect accepts an inspector function that has same arguments as the Rediser.Set
func (mmSet *mRediserMockSet) Inspect(f func(ctx context.Context, s1 string, ba1 []byte, d1 time.Duration)) *mRediserMockSet {
	if mmSet.mock.inspectFuncSet != nil {
		mmSet.mock.t.Fatalf("Inspect function is already set for RediserMock.Set")
	}

	mmSet.mock.inspectFuncSet = f

	return mmSet
}

// Return sets up results that will be returned by Rediser.Set
func (mmSet *mRediserMockSet) Return(s2 string, err error) *RediserMock {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("RediserMock.Set mock is already set by Set")
	}

	if mmSet.defaultExpectation == nil {
		mmSet.defaultExpectation = &RediserMockSetExpectation{mock: mmSet.mock}
	}
	mmSet.defaultExpectation.results = &RediserMockSetResults{s2, err}
	return mmSet.mock
}

// Set uses given function f to mock the Rediser.Set method
func (mmSet *mRediserMockSet) Set(f func(ctx context.Context, s1 string, ba1 []byte, d1 time.Duration) (s2 string, err error)) *RediserMock {
	if mmSet.defaultExpectation != nil {
		mmSet.mock.t.Fatalf("Default expectation is already set for the Rediser.Set method")
	}

	if len(mmSet.expectations) > 0 {
		mmSet.mock.t.Fatalf("Some expectations are already set for the Rediser.Set method")
	}

	mmSet.mock.funcSet = f
	return mmSet.mock
}

// When sets expectation for the Rediser.Set which will trigger the result defined by the following
// Then helper
func (mmSet *mRediserMockSet) When(ctx context.Context, s1 string, ba1 []byte, d1 time.Duration) *RediserMockSetExpectation {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("RediserMock.Set mock is already set by Set")
	}

	expectation := &RediserMockSetExpectation{
		mock:   mmSet.mock,
		params: &RediserMockSetParams{ctx, s1, ba1, d1},
	}
	mmSet.expectations = append(mmSet.expectations, expectation)
	return expectation
}

// Then sets up Rediser.Set return parameters for the expectation previously defined by the When method
func (e *RediserMockSetExpectation) Then(s2 string, err error) *RediserMock {
	e.results = &RediserMockSetResults{s2, err}
	return e.mock
}

// Set implements actions.Rediser
func (mmSet *RediserMock) Set(ctx context.Context, s1 string, ba1 []byte, d1 time.Duration) (s2 string, err error) {
	mm_atomic.AddUint64(&mmSet.beforeSetCounter, 1)
	defer mm_atomic.AddUint64(&mmSet.afterSetCounter, 1)

	if mmSet.inspectFuncSet != nil {
		mmSet.inspectFuncSet(ctx, s1, ba1, d1)
	}

	mm_params := RediserMockSetParams{ctx, s1, ba1, d1}

	// Record call args
	mmSet.SetMock.mutex.Lock()
	mmSet.SetMock.callArgs = append(mmSet.SetMock.callArgs, &mm_params)
	mmSet.SetMock.mutex.Unlock()

	for _, e := range mmSet.SetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s2, e.results.err
		}
	}

	if mmSet.SetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSet.SetMock.defaultExpectation.Counter, 1)
		mm_want := mmSet.SetMock.defaultExpectation.params
		mm_want_ptrs := mmSet.SetMock.defaultExpectation.paramPtrs

		mm_got := RediserMockSetParams{ctx, s1, ba1, d1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSet.t.Errorf("RediserMock.Set got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.s1 != nil && !minimock.Equal(*mm_want_ptrs.s1, mm_got.s1) {
				mmSet.t.Errorf("RediserMock.Set got unexpected parameter s1, want: %#v, got: %#v%s\n", *mm_want_ptrs.s1, mm_got.s1, minimock.Diff(*mm_want_ptrs.s1, mm_got.s1))
			}

			if mm_want_ptrs.ba1 != nil && !minimock.Equal(*mm_want_ptrs.ba1, mm_got.ba1) {
				mmSet.t.Errorf("RediserMock.Set got unexpected parameter ba1, want: %#v, got: %#v%s\n", *mm_want_ptrs.ba1, mm_got.ba1, minimock.Diff(*mm_want_ptrs.ba1, mm_got.ba1))
			}

			if mm_want_ptrs.d1 != nil && !minimock.Equal(*mm_want_ptrs.d1, mm_got.d1) {
				mmSet.t.Errorf("RediserMock.Set got unexpected parameter d1, want: %#v, got: %#v%s\n", *mm_want_ptrs.d1, mm_got.d1, minimock.Diff(*mm_want_ptrs.d1, mm_got.d1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSet.t.Errorf("RediserMock.Set got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSet.SetMock.defaultExpectation.results
		if mm_results == nil {
			mmSet.t.Fatal("No results are set for the RediserMock.Set")
		}
		return (*mm_results).s2, (*mm_results).err
	}
	if mmSet.funcSet != nil {
		return mmSet.funcSet(ctx, s1, ba1, d1)
	}
	mmSet.t.Fatalf("Unexpected call to RediserMock.Set. %v %v %v %v", ctx, s1, ba1, d1)
	return
}

// SetAfterCounter returns a count of finished RediserMock.Set invocations
func (mmSet *RediserMock) SetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSet.afterSetCounter)
}

// SetBeforeCounter returns a count of RediserMock.Set invocations
func (mmSet *RediserMock) SetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSet.beforeSetCounter)
}

// Calls returns a list of arguments used in each call to RediserMock.Set.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSet *mRediserMockSet) Calls() []*RediserMockSetParams {
	mmSet.mutex.RLock()

	argCopy := make([]*RediserMockSetParams, len(mmSet.callArgs))
	copy(argCopy, mmSet.callArgs)

	mmSet.mutex.RUnlock()

	return argCopy
}

// MinimockSetDone returns true if the count of the Set invocations corresponds
// the number of defined expectations
func (m *RediserMock) MinimockSetDone() bool {
	for _, e := range m.SetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSet != nil && mm_atomic.LoadUint64(&m.afterSetCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetInspect logs each unmet expectation
func (m *RediserMock) MinimockSetInspect() {
	for _, e := range m.SetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RediserMock.Set with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetCounter) < 1 {
		if m.SetMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RediserMock.Set")
		} else {
			m.t.Errorf("Expected call to RediserMock.Set with params: %#v", *m.SetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSet != nil && mm_atomic.LoadUint64(&m.afterSetCounter) < 1 {
		m.t.Error("Expected call to RediserMock.Set")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RediserMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCloseInspect()

			m.MinimockExpireInspect()

			m.MinimockGetInspect()

			m.MinimockPingInspect()

			m.MinimockSetInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RediserMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RediserMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCloseDone() &&
		m.MinimockExpireDone() &&
		m.MinimockGetDone() &&
		m.MinimockPingDone() &&
		m.MinimockSetDone()
}
